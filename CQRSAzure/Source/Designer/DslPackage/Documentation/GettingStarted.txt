Getting Started
===============

There is an article describing the use of this designer which I thoroughly recommend - see https://www.codeproject.com/Articles/1062409/CQRS-designer.

Introduction
------------
One of the factors holding back adoption of the Command Query Responsibility Pattern (CQRS) and the related technology of event sourcing (ES) in the .NET community is 
the lack of tooling to generate and manipulate these models in a way that is familar to users of Entity Framework - that is to say graphically by composition with the 
resulting model then turned into code.
This Visual Studio plug-in designer is an early attempt to bridge that gap.  It allows you graphically to design domain models consisting of aggregate identifiers, events, 
projections, commands, queries and identity groups.

Terminology
===========
In the tool (and this article) the following terms are used.  My usage may not map 100% to other CQRS documentation so a quick review of this is recommended before you proceed:-

Aggregate Identifier
--------------------
An aggregate identifier is a thing which can be uniquely identified and to which events can occur about which we are interested.  This can correspond to a physical thing (lika a car, 
office, person) or a logical entity in exactly the same way as an entity does in the entity relationship model.
Everything that happens is concerned with just one instance of just one type of aggregate identifier.  In addition, every aggregate must have an unique identifier, or a system 
provided unique key (this could be an incremental integer or a GUID).  This may be given a business-meaningful name if one exists or simply "Key" or "Identifier" if it does not.
An aggregate may have instance data members but in its purest form these should only related to identity (what the instance is) rather than any transitive state.

Event
-----
An event is a record that something of interest happened to the object identified by the aggregate identifier.
Events are stored in order of occurrence and this allows for the most powerful aspects of event sourcing - the ability to recreate the state of your object as it was at any given 
point in time by replaying the events into it. (These views of the state of an aggregate when events are applied are generated by projections).

Each event can only be linked to one aggregate identifier.

Each event type must have an unique name of be uniquely identifiable.

Behind the scenes a sequence and timestamp property can be added to indicate the order in which events were recorded and the relation between this and real-world time.

Projection
----------
A projection takes the stream of events that were recorded against a given aggregate identifier and uses them to create a view of the state of the object that the aggregate represents 
as at a given point in time.

A projection can only apply to one aggregation identifier.  If you want to project the state of multiple aggregate identifiers a seperate projection must be run for each one but this 
is an entirely decoupled operation so can be performed in a highly parrallel manner.

A projection can filter which events it does or does not process - events which have no impact on the state of the projection can be ignored.  For events that are handled the 
projection properties can be updated according to the properties of the event being handled.

Query definition / Query Handler
--------------------------------
A query definition defines how you get information out of the system.  The definition identifies the aggregate against which it will run, the return data type it will supply and any 
additional parameters to the query.
When designing the query definition you should approach it from the user-experience point of view.  In practice this means concentrating on what (and how) the user wants to know and 
not what is available to tell them about.
When the code is generated for a query definition separate classes are created for the definition and the handler.  This allows the definition to be used as a model in an MVC (or MVVM) 
based application without it caring how the actual query processing occurs on the back end.

Command definition / Command Handler
------------------------------------
A command definition and handler is how you get information into the system or cause state changes to occur.  The command has defined parameters that provide additional data payload 
to the system, and must uniquely identify the aggregate it is applied to.

Each command instance has an unique instance identifier which can be used to log the impact of the command.
Note that a command does not neccessarily have to come from a human operative - anything that has intent to add an event or cause a state change can be expressed as a command.
When the code is generated for a command definition separate classes are created for the definition and the handler.  This allows the definition to be used as an input model in an 
MVC (or MVVM) based application without it caring how the actual command processing occurs on the back end.

Identity group
--------------
An identity group is a business-meaningful grouping of zero or more aggregate identifier instances.  Named identity groups are used so that query definitions and projections can be 
composed in a business centric manner. 
For example, the identity group "Premier League" would identify a business meaningful collection of "Football team" instances, or the identity group "Non domiciled accounts" could 
identify a business meaningful collection of bank accounts.
Each Identity Group has its own underlying event stream with two very simple events in it - an IdentityAdded event which adds the identified aggregate to the list and an 
IdentityRemoved event which add or remove items from the group. This event stream can be played to regenerate the membership of the group as at any given point in time.
Membership of an identity group is evaluated by a specialised form of a projection known as a Classifier.  This runs over the event streams of the aggregate identifiers to decide 
if they are in or out of the identity group.